# 练习 35：解释器

> 原文：[Exercise 35: Interpreters](https://learncodethehardway.org/more-python-book/ex35.html)

> 译者：[飞龙](https://github.com/wizardforcel)

> 协议：[CC BY-NC-SA 4.0](http://creativecommons.org/licenses/by-nc-sa/4.0/)

> 自豪地采用[谷歌翻译](https://translate.google.cn/)

解析中的最后一个练习应该既具有挑战性又有趣。你终于可以看到，你的微型 Python 脚本运行并做了一些事情。难以理解这个章节和解析的概念很正常。如果你发现你已经到达了这里，而且你不太明白发生了什么，请退后一步，再考虑在这一部分做一些练习。在继续之前，重复几次这个章节，这可以帮助你在最后两个练习中制作自己的小语言。

我故意不会在本练习中包含任何代码，以便你必须根据解释器工作方式的描述来尝试。你已经有了 Python 作为参考，我们的微型 Python 示例应该如何操作这些小语句。你知道如何用访问者模式来遍历你的解析树。剩下的就是让你编写一个解释器，它可以将它们结合在一起，并使你的小脚本运行。

## 解释器和编译器

在编程语言的世界里，存在解释语言和编译语言。编译语言接受你的输入的源码，并进行扫描，解析和分析阶段。然后，编译器基于这个分析产生机器码，通过遍历它并编写真正的（或假的）计算机所需的字节，来使 CPU 运行。一些编译器增加了一个额外的步骤，将输入的源码翻译成通用的“中间语言”，然后将其编译为机器的字节。编译器通常是确定的，因为你通常不能仅仅运行编译器，而是首先必须通过编译器运行源代码，然后执行结果。C 是一个经典的编译器，你可以这样运行 C 程序：

```
$ cc ex1.c -o ex1
$ ./ex1
```

`cc`命令是“C 编译器”的意思，也就是说，你选取了文件`ex1.c`，扫描，解析，并进行分析，然后输出可执行字节到文件`ex1`。一旦你完成了，你就可以像其他任何程序一样运行它。

解释器不会生成你运行的编译后字节码，而是直接运行并分析结果。它“解释”输入语言，就像我把我的汉语转换为我朋友的泰语。它加载源文件，然后像编译器那样进行扫描，解析和分析。之后，它只是使用解释器的自己的语言（在这里是 Python），来根据分析来运行它。

如果我们要在 Python 中实现 JavaScript 解释器，我们会“使用 Python 解释 JavaScript”。JavaScript 是我的汉语，一个解释器正在为我将其凭空解释为 Python（泰语）。如果我想用 Python 解释 JavaScript 的`1 + 2`，我可能会这样做：

+   扫描`1 + 2`并产生记号`INT(1) PLUS INT(2)`。

+   将其解析为表达式`AddExpr(IntExpr(1), IntExpr(2))`

+   分析它，将文本`1`和`2`转换为实际的 Python 整数。

+   使用 Python 代码`result = 1 + 2`解释它，我可以将其转给剩余的解析树。

与之相比，编译器会做 1~3 的任何事情。但是在第四步它会编写字节码（机器码）到另一个文件，我可以将其运行在 CPU 上。

## Python 两者都是

Python 更现代化，通过几乎完成编译和解释，利用更快的计算机。它将像解释器一样工作，所以你不必经历编译阶段。但是，解释器出奇地慢，所以 Python 有一个内部的虚拟机。当你运行脚本时，例如`python ex1.py`，Python 实际上会运行它并将其编译到`__pycache__`目录中的`ex1.cpython -36.pyc`文件。该文件是字节码，Python 程序知道如何加载和运行，它的工作原理就像假的机器代码。

> 译者注：但是没有 JIT 的情况下还是很慢。

你的解释器永远不会，也不应该是这样的。你的解释器应该只是扫描，解析，分析和解释微型 Python 脚本。

## 如何编写解释器

当你编写解释器时，你将需要工作在所有三个阶段之间，来修复你错过或做错的东西。我建议你先添加数字，然后再处理更复杂的表达式，直到你的脚本能够运行。我会像这样完成它：

+   将你的第一个`interpret`方法添加到`AddExpr`类，并让它打印出一条消息。
+   让你的解释器能够可靠地访问这个类，并传入它需要的`PunyPyWorld`。
+   一旦你完成了，你可以调用`AddExpr.interpret`来计算它的两个表达式的和，并返回结果。
+   之后，你必须弄清楚，这个`interpret`步骤的结果应该到哪里去。为了保持简单，让我们假设微型 Python 是一种基于表达式的语言，所以一切都返回一个值。在这种情况下，对一个解释器的调用总是具有返回值，父调用可以使用它。
+   最后，由于微型 Python 基于表达式，你可以让你的`Interpreter`打印出其`interpret`调用的最终结果。
+   如果你这样做，你将会获得解释器的基础知识，你可以开始执行所有其他的`interpret`方法，使其运行。

## 挑战练习

编写微型 Python 的解释器，应该只涉及编写另一个访问者模式，它遍历分析后的解析树，并完成解析树让它做的任何事情。你唯一的目标就是让这个很小的（甚至是微型的）脚本运行。这似乎是愚蠢的，因为这只是三行代码，但它涵盖编程语言中的各种主题：变量，加法，表达式，函数定义和函数调用。如果你实现了`if`语句，你几乎可以有一个可工作的编程语言。

你的任务是编写一个`PunyPyInterpreter`类，它接受`PunyPyWorld`和`PunyPyAnalyzer`的运行结果来执行脚本。你必须实现`print`，仅仅用于打印其变量，但其余的代码，应该在你遍历每个产生式类的时候运行。

## 研究性学习

+   一旦你拥有了`PunyPyInterpreter`，你应该实现`if`语句和布尔表达式，然后扩展你的语言测试集，来确保这是有效的。尽可能为这个小型 Python 解释器增加功能。
+   如何使微型 Python 也拥有语句？


## 深入学习

你应该能够学习尽可能多的语言的语法和规范。继续寻找一些语言并学习它们，但是使用该语言的源代码来完成。你还应该完整学习 <https://tools.ietf.org/html/rfc5234> 上面的 IETF ABNF 规范，来为自己准备接下来的两项练习。
