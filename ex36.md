# 练习 36：简单的计算器

> 原文：[Exercise 36: Simple Calculator](https://learncodethehardway.org/more-python-book/ex36.html)

> 译者：[飞龙](https://github.com/wizardforcel)

> 协议：[CC BY-NC-SA 4.0](http://creativecommons.org/licenses/by-nc-sa/4.0/)

> 自豪地采用[谷歌翻译](https://translate.google.cn/)

这个挑战是创建一个简单的代数计算器，使用你所学到的关于解析的一切。你将需要设计一种语言，用于使用变量进行基本数学运算，为该语言创建 ABNF，并为其编写扫描器，解析器，分析器和解释器。这实际上对于简单的计算器语言可能是小题大做，因为不会有任何嵌套的结构，如函数，但是无论如何都要理解完整的过程。

## 挑战练习

简单的代数语言对于不同的人来说意思也不同，所以我希望你试试 Unix 命令`bc`。这是我运行`bc`命令的一个例子：

```
$ bc
bc 1.06
Copyright 1991-1994, 1997, 1998, 2000 Free Software Foundation, Inc.
This is free software with ABSOLUTELY NO WARRANTY.
For details type `warranty'.
x = 10
y = 11
j = x * y
j
110
```

你需要创建变量，输入数字（包括整数和浮点数），并拥有尽可能多的，你可以想到的运算符。你最有可能使用`bc`，甚至是 Python 的 shell，并且在你弄明白时候为它编写 ABNF。请记住，你的 ABNF 几乎是伪代码，不必形式上正确，只需足够接近来创建扫描器和解析器。

一旦“简单制作”了 ABNF 形式的语法，你可以坐下来创建扫描器和解析器。我会写一套简单的脚本，来练习你认为语言应该做的事情，然后让你的测试套件，在每个阶段通过你的计算器运行它们。这样做可以更容易地测试计算器。

完成解析器之后，你应该编写一个分析器来巩固吗，并检查输入的语义。在这样一种简单的语言中，它可能不仅仅是你需要的东西，但这是一个练习，用小型玩具语言完成整个过程。请记住，分析器的重要任务是，跟踪脚本中不同位置的变量定义，以便在执行过程中它们可由解释器访问。

在分析器创建可执行解析树之后，你可以编写一个运行它的解释器。如练习 35 所述，你可以使用两种方式来编写解释器。一个是你创建一个“机器”，知道如何运行语法产生式，作为一系列的输入。这将把你的语法产生式类（`Expression`，`Assignment`等）视为机器代码，并且简单地执行它们所包含的内容。例如 Python 这样的 OOP 语言的另一种风格是，让每个产生式类知道如何运行自身。在这种风格中，这些类很“聪明”，并且接受他们的环境，只需要做他们需要做的事情，来使事情发生。然后，你只需“遍历”语法产生式列表，并调用`run`，直到调用完毕。

你选择哪一个，决定了你在哪里存储你的小型解释器的状态。如果你制作`Interpreter`类，仅仅执行产生式数据对象，那么解释器可以跟踪所有的状态，但语言更难扩展，因为你必须为每个产生式类改进`Interpreter`。如果你的产生式类知道如何执行自己的代码，那么扩展语言很容易，但是你必须找到一种方法，在每个产生式之间传递计算机状态。

处理它的时候，我建议你仅仅以一个非常小的表达式来起步，比如加法。让整个系统首先能够工作，从扫描器一直到运行简单的加法。然后，如果你不喜欢这个设计，你可以把它丢掉，使用不同的设计重做。一旦你的设计能够工作，你就可以使用更多功能来扩展语言。

## 研究性学习

+   最好的研究性学习是创建函数来执行计算和返回结果。如果你可以这样做，那么你的设计将可能适用于更大的语言。
+   接下来要尝试的是，使用`if`语句和`boolean`检查来实现控制流。如果这太难了，那就对了，但请试试看。

## 深入学习

尽你所能来研究`bc`或 Python 语言。尝试找到其他语法文件来阅读和学习，特别是任何 IETF 协议的描述。IETF 的规范（像湿巾那样）让人兴奋，但它们是个很好的练习。
